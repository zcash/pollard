use std::iter;
use std::marker::PhantomData;

use halo2::arithmetic::FieldExt;

pub(crate) mod grain;
pub(crate) mod mds;

#[cfg(test)]
mod test_vectors;

use grain::SboxType;

/// A specification for a Poseidon permutation.
pub trait Spec<F: FieldExt> {
    /// The type used to hold permutation state, or equivalent-length constant values.
    ///
    /// This must be an array of length [`Spec::arity`], that defaults to all-zeroes.
    type State: Default + AsRef<[F]> + AsMut<[F]>;

    /// The type used to hold duplex sponge state.
    ///
    /// This must be an array of length equal to the rate of the duplex sponge (allowing
    /// for a capacity consistent with this specification's security level), that defaults
    /// to `[None; RATE]`.
    type Rate: Default + AsRef<[Option<F>]> + AsMut<[Option<F>]>;

    /// The arity of this specification.
    fn arity() -> usize;

    /// The number of full rounds for this specification.
    fn full_rounds() -> usize;

    /// The number of partial rounds for this specification.
    fn partial_rounds() -> usize;

    /// The S-box for this specification.
    fn sbox(val: F) -> F;

    /// Side-loaded index of the first correct and secure MDS that will be generated by
    /// the reference implementation.
    ///
    /// This is used by the default implementation of [`Spec::constants`]. If you are
    /// hard-coding the constants, you may leave this unimplemented.
    fn secure_mds(&self) -> usize;

    /// Generates `(round_constants, mds, mds^-1)` corresponding to this specification.
    fn constants(&self) -> (Vec<Self::State>, Vec<Self::State>, Vec<Self::State>) {
        let t = Self::arity();
        let r_f = Self::full_rounds();
        let r_p = Self::partial_rounds();

        let mut grain = grain::Grain::new(SboxType::Pow, t as u16, r_f as u16, r_p as u16);

        let round_constants = (0..(r_f + r_p))
            .map(|_| {
                let mut rc_row = Self::State::default();
                for (rc, value) in rc_row
                    .as_mut()
                    .iter_mut()
                    .zip((0..t).map(|_| grain.next_field_element()))
                {
                    *rc = value;
                }
                rc_row
            })
            .collect();

        let (mds, mds_inv) = mds::generate_mds(&mut grain, t, self.secure_mds());

        (
            round_constants,
            mds.into_iter()
                .map(|row| {
                    let mut mds_row = Self::State::default();
                    for (entry, value) in mds_row.as_mut().iter_mut().zip(row.into_iter()) {
                        *entry = value;
                    }
                    mds_row
                })
                .collect(),
            mds_inv
                .into_iter()
                .map(|row| {
                    let mut mds_row = Self::State::default();
                    for (entry, value) in mds_row.as_mut().iter_mut().zip(row.into_iter()) {
                        *entry = value;
                    }
                    mds_row
                })
                .collect(),
        )
    }
}

/// Poseidon-256 with arity 3, using the `x^5` S-box.
#[derive(Debug)]
pub struct P256Pow5T3<F: FieldExt> {
    secure_mds: usize,
    _field: PhantomData<F>,
}

impl<F: FieldExt> P256Pow5T3<F> {
    pub fn new(secure_mds: usize) -> Self {
        P256Pow5T3 {
            secure_mds,
            _field: PhantomData::default(),
        }
    }
}

impl<F: FieldExt> Spec<F> for P256Pow5T3<F> {
    type State = [F; 3];
    type Rate = [Option<F>; 2];

    fn arity() -> usize {
        3
    }

    fn full_rounds() -> usize {
        8
    }

    fn partial_rounds() -> usize {
        120
    }

    fn sbox(val: F) -> F {
        val.pow_vartime(&[5])
    }

    fn secure_mds(&self) -> usize {
        self.secure_mds
    }
}

/// Runs the Poseidon permutation on the given state.
fn permute<F: FieldExt, S: Spec<F>>(
    state: &mut S::State,
    mds: &[S::State],
    round_constants: &[S::State],
) {
    // TODO: Check what should happen for odd number of full rounds.
    let r_f = S::full_rounds() / 2;
    let r_p = S::partial_rounds();

    let apply_mds = |state: &mut S::State| {
        let mut new_state = S::State::default();
        // Matrix multiplication
        #[allow(clippy::needless_range_loop)]
        for i in 0..S::arity() {
            for j in 0..S::arity() {
                new_state.as_mut()[i] += mds[i].as_ref()[j] * state.as_ref()[j];
            }
        }
        *state = new_state;
    };

    let full_round = |state: &mut S::State, rcs: &S::State| {
        for (word, rc) in state.as_mut().iter_mut().zip(rcs.as_ref().iter()) {
            *word = S::sbox(*word + rc);
        }
        apply_mds(state);
    };

    let part_round = |state: &mut S::State, rcs: &S::State| {
        for (word, rc) in state.as_mut().iter_mut().zip(rcs.as_ref().iter()) {
            *word += rc;
        }
        // In a partial round, the S-box is only applied to the first state word.
        state.as_mut()[0] = S::sbox(state.as_ref()[0]);
        apply_mds(state);
    };

    iter::empty()
        .chain(iter::repeat(&full_round as &dyn Fn(&mut S::State, &S::State)).take(r_f))
        .chain(iter::repeat(&part_round as &dyn Fn(&mut S::State, &S::State)).take(r_p))
        .chain(iter::repeat(&full_round as &dyn Fn(&mut S::State, &S::State)).take(r_f))
        .zip(round_constants.iter())
        .fold(state, |state, (round, rcs)| {
            round(state, rcs);
            state
        });
}

fn poseidon_duplex<F: FieldExt, S: Spec<F>>(
    state: &mut S::State,
    input: &S::Rate,
    mds_matrix: &[S::State],
    round_constants: &[S::State],
) -> S::Rate {
    // `Iterator::zip` short-circuits when one iterator completes, so this will only
    // mutate the rate portion of the state.
    for (word, value) in state.as_mut().iter_mut().zip(input.as_ref().iter()) {
        // TODO: Decide on a padding strategy, if we ever need to use Poseidon with
        // incomplete state input.
        *word += value.unwrap();
    }

    permute::<F, S>(state, mds_matrix, round_constants);

    let mut output = S::Rate::default();
    for (word, value) in output.as_mut().iter_mut().zip(state.as_ref().iter()) {
        *word = Some(*value);
    }
    output
}

enum SpongeState<F: FieldExt, S: Spec<F>> {
    Absorbing(S::Rate),
    Squeezing(S::Rate),
}

impl<F: FieldExt, S: Spec<F>> SpongeState<F, S> {
    fn absorb(val: F) -> Self {
        let mut input = S::Rate::default();
        input.as_mut()[0] = Some(val);
        SpongeState::Absorbing(input)
    }
}

/// A Poseidon duplex sponge.
pub struct Duplex<F: FieldExt, S: Spec<F>> {
    sponge: SpongeState<F, S>,
    state: S::State,
    mds_matrix: Vec<S::State>,
    round_constants: Vec<S::State>,
    _marker: PhantomData<S>,
}

impl<F: FieldExt, S: Spec<F>> Duplex<F, S> {
    /// Constructs a new duplex sponge for the given Poseidon specification.
    pub fn new(spec: S) -> Self {
        let (round_constants, mds_matrix, _) = spec.constants();

        Duplex {
            sponge: SpongeState::Absorbing(S::Rate::default()),
            state: S::State::default(),
            mds_matrix,
            round_constants,
            _marker: PhantomData::default(),
        }
    }

    /// Absorbs an element into the sponge.
    pub fn absorb(&mut self, value: F) {
        match self.sponge {
            SpongeState::Absorbing(ref mut input) => {
                for entry in input.as_mut().iter_mut() {
                    if entry.is_none() {
                        *entry = Some(value);
                        return;
                    }
                }

                // We've already absorbed as many elements as we can
                let _ = poseidon_duplex::<F, S>(
                    &mut self.state,
                    &input,
                    &self.mds_matrix,
                    &self.round_constants,
                );
                self.sponge = SpongeState::absorb(value);
            }
            SpongeState::Squeezing(_) => {
                // Drop the remaining output elements
                self.sponge = SpongeState::absorb(value);
            }
        }
    }

    /// Squeezes an element from the sponge.
    pub fn squeeze(&mut self) -> F {
        loop {
            match self.sponge {
                SpongeState::Absorbing(ref input) => {
                    self.sponge = SpongeState::Squeezing(poseidon_duplex::<F, S>(
                        &mut self.state,
                        &input,
                        &self.mds_matrix,
                        &self.round_constants,
                    ));
                }
                SpongeState::Squeezing(ref mut output) => {
                    for entry in output.as_mut().iter_mut() {
                        if let Some(e) = entry.take() {
                            return e;
                        }
                    }

                    // We've already squeezed out all available elements
                    self.sponge = SpongeState::Absorbing(S::Rate::default());
                }
            }
        }
    }
}

/// A Poseidon hash function, built around a duplex sponge.
pub struct Hash<F: FieldExt, S: Spec<F>>(Duplex<F, S>);

impl<F: FieldExt, S: Spec<F>> Hash<F, S> {
    /// Initializes a new hasher.
    pub fn init(spec: S) -> Self {
        Hash(Duplex::new(spec))
    }

    /// Updates the hasher with the given value.
    pub fn update(&mut self, value: F) {
        self.0.absorb(value);
    }

    /// Finalizes the hasher, returning its output.
    pub fn finalize(mut self) -> F {
        // TODO: Check which state element other implementations use.
        self.0.squeeze()
    }
}
